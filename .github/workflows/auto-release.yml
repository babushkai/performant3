name: Auto Release

on:
  pull_request:
    types: [closed]
    branches: [main, master]

permissions:
  contents: write
  pull-requests: read

env:
  APP_NAME: MacML
  BUNDLE_ID: com.macml.app

jobs:
  check-release:
    name: Check if Release Needed
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true
    outputs:
      should_release: ${{ steps.check.outputs.should_release }}
      bump_type: ${{ steps.check.outputs.bump_type }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Determine version bump type
        id: check
        env:
          PR_LABELS: ${{ toJson(github.event.pull_request.labels.*.name) }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          echo "PR Labels: $PR_LABELS"
          echo "PR Title: $PR_TITLE"

          BUMP_TYPE=""
          SHOULD_RELEASE="false"

          # Check PR labels first (highest priority)
          if echo "$PR_LABELS" | grep -q '"release:major"'; then
            BUMP_TYPE="major"
            SHOULD_RELEASE="true"
          elif echo "$PR_LABELS" | grep -q '"release:minor"'; then
            BUMP_TYPE="minor"
            SHOULD_RELEASE="true"
          elif echo "$PR_LABELS" | grep -q '"release:patch"'; then
            BUMP_TYPE="patch"
            SHOULD_RELEASE="true"
          elif echo "$PR_LABELS" | grep -q '"release:skip"'; then
            BUMP_TYPE=""
            SHOULD_RELEASE="false"
          else
            # Fall back to conventional commit detection from PR title
            if echo "$PR_TITLE" | grep -qiE "^(breaking|!:)"; then
              BUMP_TYPE="major"
              SHOULD_RELEASE="true"
            elif echo "$PR_TITLE" | grep -qiE "^feat(\(.+\))?:"; then
              BUMP_TYPE="minor"
              SHOULD_RELEASE="true"
            elif echo "$PR_TITLE" | grep -qiE "^fix(\(.+\))?:"; then
              BUMP_TYPE="patch"
              SHOULD_RELEASE="true"
            elif echo "$PR_TITLE" | grep -qiE "^(docs|chore|style|refactor|perf|test|ci)(\(.+\))?:"; then
              # These don't trigger releases by default
              BUMP_TYPE=""
              SHOULD_RELEASE="false"
            else
              # Default: patch release for any other merged PR
              BUMP_TYPE="patch"
              SHOULD_RELEASE="true"
            fi
          fi

          # Check for BREAKING CHANGE in body (overrides to major)
          if [ "$SHOULD_RELEASE" = "true" ] && echo "$PR_BODY" | grep -q "BREAKING CHANGE"; then
            BUMP_TYPE="major"
          fi

          echo "bump_type=$BUMP_TYPE" >> $GITHUB_OUTPUT
          echo "should_release=$SHOULD_RELEASE" >> $GITHUB_OUTPUT
          echo "Determined: bump_type=$BUMP_TYPE, should_release=$SHOULD_RELEASE"

  bump-and-release:
    name: Bump Version and Release
    needs: check-release
    if: needs.check-release.outputs.should_release == 'true'
    runs-on: macos-14

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get current version
        id: current
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          CURRENT_VERSION=${LATEST_TAG#v}
          echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          echo "Current version: $CURRENT_VERSION"

      - name: Calculate new version
        id: version
        run: |
          CURRENT="${{ steps.current.outputs.current_version }}"
          BUMP_TYPE="${{ needs.check-release.outputs.bump_type }}"

          # Parse version components
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT"
          PATCH=${PATCH%%-*}  # Remove any pre-release suffix

          case $BUMP_TYPE in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "New version: $NEW_VERSION (bump type: $BUMP_TYPE)"

      - name: Update Info.plist
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          python3 << EOF
          import plistlib

          with open('Info.plist', 'rb') as f:
              plist = plistlib.load(f)

          plist['CFBundleShortVersionString'] = '$VERSION'
          plist['CFBundleVersion'] = '$VERSION'

          with open('Info.plist', 'wb') as f:
              plistlib.dump(plist, f)

          print(f"Updated Info.plist to version $VERSION")
          EOF

      - name: Commit version bump
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add Info.plist
          git commit -m "chore: bump version to $VERSION [skip ci]"
          git push

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache Swift packages
        uses: actions/cache@v5
        with:
          path: |
            .build
            ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Resolve dependencies
        run: swift package resolve

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "No signing certificate configured, skipping..."
            exit 0
          fi

          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Build application
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building $APP_NAME version $VERSION..."
          xcodebuild -scheme MacML \
            -destination 'platform=macOS' \
            -configuration Release \
            -derivedDataPath "${{ runner.temp }}/DerivedData" \
            build

      - name: Package application bundle
        env:
          VERSION: ${{ steps.version.outputs.version }}
          SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          # Use the known derivedDataPath
          DERIVED_DATA="${{ runner.temp }}/DerivedData/Build/Products/Release"

          APP_DIR="${APP_NAME}.app"
          rm -rf "$APP_DIR"
          mkdir -p "$APP_DIR/Contents/MacOS"
          mkdir -p "$APP_DIR/Contents/Resources"
          mkdir -p "$APP_DIR/Contents/Frameworks"

          cp "$DERIVED_DATA/MacML" "$APP_DIR/Contents/MacOS/"

          cp Info.plist "$APP_DIR/Contents/"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" "$APP_DIR/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" "$APP_DIR/Contents/Info.plist"

          if [ -d "$DERIVED_DATA/mlx-swift_Cmlx.bundle" ]; then
            cp -R "$DERIVED_DATA/mlx-swift_Cmlx.bundle" "$APP_DIR/Contents/Resources/"
          fi

          for bundle in "$DERIVED_DATA"/*.bundle; do
            [ -d "$bundle" ] && cp -R "$bundle" "$APP_DIR/Contents/Resources/"
          done

          if [ -d "Resources/Scripts" ]; then
            mkdir -p "$APP_DIR/Contents/Resources/Scripts"
            cp -R Resources/Scripts/* "$APP_DIR/Contents/Resources/Scripts/"
          fi

          # Copy app icon
          if [ -f "Resources/AppIcon.icns" ]; then
            cp "Resources/AppIcon.icns" "$APP_DIR/Contents/Resources/"
          fi

          for framework in "$DERIVED_DATA/PackageFrameworks"/*.framework; do
            [ -d "$framework" ] && cp -R "$framework" "$APP_DIR/Contents/Frameworks/"
          done

          echo -n "APPL????" > "$APP_DIR/Contents/PkgInfo"

          if [ -n "$SIGNING_IDENTITY" ]; then
            codesign --force --deep --options runtime --sign "$SIGNING_IDENTITY" "$APP_DIR"
          else
            codesign --force --deep --sign - "$APP_DIR"
          fi

      - name: Notarize application
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          if [ -z "$APPLE_ID" ] || [ -z "$SIGNING_IDENTITY" ]; then
            echo "Notarization not configured, skipping..."
            exit 0
          fi

          ditto -c -k --keepParent "${APP_NAME}.app" "${APP_NAME}.zip"
          xcrun notarytool submit "${APP_NAME}.zip" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --wait
          xcrun stapler staple "${APP_NAME}.app"
          rm "${APP_NAME}.zip"

      - name: Create DMG
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          DMG_NAME="${APP_NAME}-${VERSION}.dmg"
          DMG_DIR="dmg_contents"
          rm -rf "$DMG_DIR"
          mkdir -p "$DMG_DIR"
          cp -R "${APP_NAME}.app" "$DMG_DIR/"
          ln -s /Applications "$DMG_DIR/Applications"
          hdiutil create -volname "$APP_NAME" -srcfolder "$DMG_DIR" -ov -format UDZO "$DMG_NAME"
          rm -rf "$DMG_DIR"
          echo "dmg_path=$DMG_NAME" >> $GITHUB_ENV

      - name: Create ZIP archive
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          ZIP_NAME="${APP_NAME}-${VERSION}.zip"
          ditto -c -k --keepParent "${APP_NAME}.app" "$ZIP_NAME"
          echo "zip_path=$ZIP_NAME" >> $GITHUB_ENV

      - name: Install git-cliff
        run: |
          brew install git-cliff

      - name: Generate changelog with git-cliff
        env:
          VERSION: ${{ steps.version.outputs.version }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_URL: ${{ github.event.pull_request.html_url }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
        run: |
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          # Generate categorized changelog using git-cliff (only for this version range)
          if [ -n "$PREV_TAG" ]; then
            git-cliff ${PREV_TAG}..HEAD --tag "v${VERSION}" --strip header -o changelog_section.md
          else
            git-cliff --tag "v${VERSION}" --strip header -o changelog_section.md
          fi

          # Create release notes header
          cat > release_notes.md << 'HEADER'
          ## What's New
          HEADER

          # Extract categorized sections from git-cliff (skip version header line)
          if [ -f changelog_section.md ]; then
            # Remove the version header line and empty lines at start, keep only category sections
            sed -n '/^### /,$ p' changelog_section.md >> release_notes.md
          fi

          # Add installation section
          cat >> release_notes.md << FOOTER

          ---

          ### üì¶ Installation

          1. Download \`${APP_NAME}-${VERSION}.dmg\`
          2. Open the DMG file
          3. Drag **MacML** to your Applications folder

          > **Note:** On first launch, right-click and select "Open" if you see a Gatekeeper warning.

          ### üíª System Requirements

          - macOS 14.0 (Sonoma) or later
          - Apple Silicon Mac (M1/M2/M3/M4)

          ### üîê Checksums

          \`\`\`
          SHA256 (DMG): $(shasum -a 256 "${APP_NAME}-${VERSION}.dmg" | awk '{print $1}')
          SHA256 (ZIP): $(shasum -a 256 "${APP_NAME}-${VERSION}.zip" | awk '{print $1}')
          \`\`\`

          ---

          **Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREV_TAG:-initial}...v${VERSION}
          FOOTER

      - name: Update CHANGELOG.md
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Generate full changelog
          git-cliff --tag "v${VERSION}" -o CHANGELOG.md

          # Commit changelog update
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG.md for v${VERSION} [skip ci]" || echo "No changelog changes to commit"
          git push || echo "Nothing to push"

      - name: Create tag and release
        env:
          VERSION: ${{ steps.version.outputs.version }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          git tag -a "v$VERSION" -m "Release v$VERSION"
          git push origin "v$VERSION"

          gh release create "v$VERSION" \
            --title "MacML v$VERSION" \
            --notes-file release_notes.md \
            "${{ env.dmg_path }}" \
            "${{ env.zip_path }}"

      - name: Cleanup keychain
        if: always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          [ -f "$KEYCHAIN_PATH" ] && security delete-keychain $KEYCHAIN_PATH || true
