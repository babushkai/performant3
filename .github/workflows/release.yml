name: Release (Manual)

# This workflow is for MANUAL releases only.
# Automatic releases on PR merge are handled by auto-release.yml

on:
  # Only trigger on manual tag push (not from auto-release)
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 1.2.3)'
        required: true
        type: string
      prerelease:
        description: 'Mark as pre-release'
        required: false
        type: boolean
        default: false
      draft:
        description: 'Create as draft release'
        required: false
        type: boolean
        default: false

permissions:
  contents: write

env:
  APP_NAME: MacML
  BUNDLE_ID: com.macml.app

jobs:
  build-and-release:
    name: Build and Release
    runs-on: macos-14  # Apple Silicon runner (required for MLX)

    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Determine version
        id: version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            VERSION="${{ inputs.version }}"
          else
            VERSION=${GITHUB_REF_NAME#v}
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: latest-stable

      - name: Cache Swift packages
        uses: actions/cache@v5
        with:
          path: |
            .build
            ~/Library/Developer/Xcode/DerivedData
          key: ${{ runner.os }}-spm-${{ hashFiles('Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-spm-

      - name: Resolve dependencies
        run: swift package resolve

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.MACOS_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.MACOS_CERTIFICATE_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Skip if no certificate configured
          if [ -z "$CERTIFICATE_BASE64" ]; then
            echo "No signing certificate configured, skipping..."
            exit 0
          fi

          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo -n "$CERTIFICATE_BASE64" | base64 --decode -o $CERTIFICATE_PATH
          security import $CERTIFICATE_PATH -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

      - name: Build application
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          echo "Building $APP_NAME version $VERSION..."

          # Build with xcodebuild (required for Metal shader compilation)
          xcodebuild -scheme MacML \
            -destination 'platform=macOS' \
            -configuration Release \
            -derivedDataPath "${{ runner.temp }}/DerivedData" \
            build

      - name: Package application bundle
        env:
          VERSION: ${{ steps.version.outputs.version }}
          SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          # Use the known derivedDataPath
          DERIVED_DATA="${{ runner.temp }}/DerivedData/Build/Products/Release"

          echo "Build products at: $DERIVED_DATA"

          # Create app bundle structure
          APP_DIR="${APP_NAME}.app"
          rm -rf "$APP_DIR"
          mkdir -p "$APP_DIR/Contents/MacOS"
          mkdir -p "$APP_DIR/Contents/Resources"
          mkdir -p "$APP_DIR/Contents/Frameworks"

          # Copy executable
          cp "$DERIVED_DATA/MacML" "$APP_DIR/Contents/MacOS/"

          # Update Info.plist with version
          cp Info.plist "$APP_DIR/Contents/"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" "$APP_DIR/Contents/Info.plist"
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $VERSION" "$APP_DIR/Contents/Info.plist"

          # Copy Metal library bundle (critical for MLX)
          if [ -d "$DERIVED_DATA/mlx-swift_Cmlx.bundle" ]; then
            cp -R "$DERIVED_DATA/mlx-swift_Cmlx.bundle" "$APP_DIR/Contents/Resources/"
            echo "Copied MLX Metal library bundle"
          fi

          # Copy other bundles
          for bundle in "$DERIVED_DATA"/*.bundle; do
            if [ -d "$bundle" ]; then
              cp -R "$bundle" "$APP_DIR/Contents/Resources/"
              echo "Copied $(basename "$bundle")"
            fi
          done

          # Copy Python training scripts
          if [ -d "Resources/Scripts" ]; then
            mkdir -p "$APP_DIR/Contents/Resources/Scripts"
            cp -R Resources/Scripts/* "$APP_DIR/Contents/Resources/Scripts/"
            echo "Copied Python training scripts"
          fi

          # Copy frameworks if any
          for framework in "$DERIVED_DATA/PackageFrameworks"/*.framework; do
            if [ -d "$framework" ]; then
              cp -R "$framework" "$APP_DIR/Contents/Frameworks/"
              echo "Copied $(basename "$framework")"
            fi
          done

          # Create PkgInfo
          echo -n "APPL????" > "$APP_DIR/Contents/PkgInfo"

          # Sign the app
          if [ -n "$SIGNING_IDENTITY" ]; then
            echo "Signing with Developer ID: $SIGNING_IDENTITY"
            codesign --force --deep --options runtime --sign "$SIGNING_IDENTITY" "$APP_DIR"
          else
            echo "Using ad-hoc signing (no Developer ID configured)"
            codesign --force --deep --sign - "$APP_DIR"
          fi

          echo "Created $APP_DIR"

      - name: Notarize application
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          # Skip if notarization not configured
          if [ -z "$APPLE_ID" ] || [ -z "$SIGNING_IDENTITY" ]; then
            echo "Notarization not configured (requires APPLE_ID and MACOS_SIGNING_IDENTITY), skipping..."
            exit 0
          fi

          # Create ZIP for notarization
          ditto -c -k --keepParent "${APP_NAME}.app" "${APP_NAME}.zip"

          # Submit for notarization
          xcrun notarytool submit "${APP_NAME}.zip" \
            --apple-id "$APPLE_ID" \
            --team-id "$APPLE_TEAM_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --wait

          # Staple the notarization ticket
          xcrun stapler staple "${APP_NAME}.app"

          rm "${APP_NAME}.zip"

      - name: Create DMG
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          DMG_NAME="${APP_NAME}-${VERSION}.dmg"

          # Create temporary directory for DMG contents
          DMG_DIR="dmg_contents"
          rm -rf "$DMG_DIR"
          mkdir -p "$DMG_DIR"
          cp -R "${APP_NAME}.app" "$DMG_DIR/"

          # Create symlink to Applications
          ln -s /Applications "$DMG_DIR/Applications"

          # Create DMG
          hdiutil create -volname "$APP_NAME" -srcfolder "$DMG_DIR" -ov -format UDZO "$DMG_NAME"

          # Cleanup
          rm -rf "$DMG_DIR"

          echo "dmg_path=$DMG_NAME" >> $GITHUB_ENV
          echo "Created $DMG_NAME"

      - name: Create ZIP archive
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          ZIP_NAME="${APP_NAME}-${VERSION}.zip"
          ditto -c -k --keepParent "${APP_NAME}.app" "$ZIP_NAME"
          echo "zip_path=$ZIP_NAME" >> $GITHUB_ENV
          echo "Created $ZIP_NAME"

      - name: Generate changelog
        id: changelog
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Get the previous tag
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            echo "Generating changelog from $PREV_TAG to HEAD"
            CHANGELOG=$(git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges | head -50)
          else
            echo "No previous tag found, using recent commits"
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" --no-merges -20)
          fi

          # Write changelog to file (handle multiline)
          echo "$CHANGELOG" > changelog.txt

      - name: Generate release notes
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          CHANGELOG=$(cat changelog.txt)

          cat << 'EOF' > release_notes.md
          ## MacML v${{ steps.version.outputs.version }}

          ### Installation

          1. Download `Performant3-${{ steps.version.outputs.version }}.dmg`
          2. Open the DMG file
          3. Drag **MacML** to your Applications folder
          4. Launch from Applications

          > **Note:** On first launch, right-click and select "Open" if you see a Gatekeeper warning (for ad-hoc signed builds).

          ### System Requirements

          - macOS 14.0 (Sonoma) or later
          - Apple Silicon Mac (M1/M2/M3/M4)

          ### What's Changed

          EOF

          cat changelog.txt >> release_notes.md

          cat << EOF >> release_notes.md

          ### Checksums

          \`\`\`
          SHA256 (DMG): $(shasum -a 256 "${APP_NAME}-${{ steps.version.outputs.version }}.dmg" | awk '{print $1}')
          SHA256 (ZIP): $(shasum -a 256 "${APP_NAME}-${{ steps.version.outputs.version }}.zip" | awk '{print $1}')
          \`\`\`

          ---
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "initial")...v${{ steps.version.outputs.version }}
          EOF

      - name: Create tag for manual release
        if: ${{ github.event_name == 'workflow_dispatch' }}
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          # Check if tag already exists
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            echo "Tag v$VERSION already exists, skipping tag creation"
          else
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "v$VERSION" -m "Release v$VERSION"
            git push origin "v$VERSION"
          fi

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ steps.version.outputs.version }}
          name: MacML v${{ steps.version.outputs.version }}
          body_path: release_notes.md
          draft: ${{ inputs.draft || false }}
          prerelease: ${{ inputs.prerelease || contains(steps.version.outputs.version, '-') }}
          files: |
            ${{ env.dmg_path }}
            ${{ env.zip_path }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Cleanup keychain
        if: always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/build.keychain
          if [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain $KEYCHAIN_PATH
          fi
